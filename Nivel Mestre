#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h> // Para medir o tempo de execu√ß√£o

// --- 1. Defini√ß√£o da Struct e Constantes ---

// Struct para representar um componente da torre
typedef struct {
    char nome[30];
    char tipo[20];
    int prioridade; // 1 (mais alta) a 10 (mais baixa)
} Componente;

// Constantes
#define MAX_COMPONENTES 20
#define CHAVE_BUSCA "chip central" // O componente-chave para a Busca Bin√°ria

// --- Vari√°veis Globais de Controle ---
Componente torre[MAX_COMPONENTES];
int numComponentes = 0;

// --- Prot√≥tipos das Fun√ß√µes ---
void inicializarDados();
void mostrarComponentes(const Componente componentes[], int tamanho);
void trocar(Componente *a, Componente *b);
void bubbleSortNome(Componente componentes[], int tamanho, long long *comparacoes);
void insertionSortTipo(Componente componentes[], int tamanho, long long *comparacoes);
void selectionSortPrioridade(Componente componentes[], int tamanho, long long *comparacoes);
int buscaBinariaPorNome(const Componente componentes[], int tamanho, const char chave[], long long *comparacoes);
void menuPrincipal();

// --- Fun√ß√µes de Utilit√°rio e Inicializa√ß√£o ---

/**
 * @brief Troca dois componentes de posi√ß√£o (usada nos algoritmos de ordena√ß√£o).
 */
void trocar(Componente *a, Componente *b) {
    Componente temp = *a;
    *a = *b;
    *b = temp;
}

/**
 * @brief Exibe o vetor de componentes de forma formatada.
 */
void mostrarComponentes(const Componente componentes[], int tamanho) {
    printf("\n--- üì¶ Componentes Atuais (%d/%d) ---\n", tamanho, MAX_COMPONENTES);
    
    if (tamanho == 0) {
        printf("Nenhum componente cadastrado.\n");
        return;
    }

    printf("+------------------------------+--------------------+--------------+\n");
    printf("| Nome do Componente           | Tipo               | Prioridade   |\n");
    printf("+------------------------------+--------------------+--------------+\n");

    for (int i = 0; i < tamanho; i++) {
        printf("| %-28s | %-18s | %-12d |\n", 
               componentes[i].nome, componentes[i].tipo, componentes[i].prioridade);
    }
    printf("+------------------------------+--------------------+--------------+\n");
}

/**
 * @brief Fun√ß√£o para cadastrar dados iniciais (simplificado) ou permitir entrada manual.
 */
void inicializarDados() {
    int opcao;
    printf("\n--- Escolha a Entrada de Dados ---\n");
    printf("1. Entrar com dados de teste pr√©-definidos (R√°pido)\n");
    printf("2. Cadastrar componentes manualmente\n");
    printf("Op√ß√£o: ");
    if (scanf("%d", &opcao) != 1) {
        printf("‚ö†Ô∏è Entrada inv√°lida. Usando dados pr√©-definidos.\n");
        opcao = 1;
    }
    while (getchar() != '\n'); // Limpa buffer

    if (opcao == 1) {
        // Dados de teste para demonstra√ß√£o r√°pida
        Componente dados[] = {
            {"cabo de forca", "suporte", 6},
            {"fusivel mestre", "controle", 2},
            {"chapa blindada", "suporte", 8},
            {"chip central", "controle", 1}, // Item-chave
            {"propulsor auxiliar", "propulsao", 3},
            {"conexao logica", "controle", 4},
            {"combustivel", "propulsao", 7},
            {"antena", "controle", 5},
            {"base metalica", "suporte", 9}
        };
        numComponentes = sizeof(dados) / sizeof(Componente);
        memcpy(torre, dados, sizeof(dados));
        printf("\n‚úÖ %d componentes de teste carregados.\n", numComponentes);
    } else {
        printf("\n‚ö†Ô∏è Para fins de agilidade, usaremos apenas 5 componentes manuais.\n");
        numComponentes = 0;
        int max = 5;
        for (int i = 0; i < max; i++) {
            printf("\nCadastro do Componente %d:\n", i + 1);
            
            printf("Nome (max 29): ");
            if (fgets(torre[i].nome, 30, stdin) != NULL) {
                torre[i].nome[strcspn(torre[i].nome, "\n")] = 0;
            }
            
            printf("Tipo (controle/suporte/propulsao): ");
            if (fgets(torre[i].tipo, 20, stdin) != NULL) {
                torre[i].tipo[strcspn(torre[i].tipo, "\n")] = 0;
            }

            printf("Prioridade (1=Mais Alta, 10=Mais Baixa): ");
            if (scanf("%d", &torre[i].prioridade) != 1) {
                 printf("‚ö†Ô∏è Prioridade inv√°lida, usando 5.\n");
                 torre[i].prioridade = 5;
            }
            while (getchar() != '\n');
            numComponentes++;
        }
        printf("\n‚úÖ %d componentes cadastrados manualmente.\n", numComponentes);
    }
}

// --------------------------------------------------------------------------
//                            ALGORITMOS DE ORDENA√á√ÉO
// --------------------------------------------------------------------------

/**
 * @brief Implementa o Bubble Sort para ordenar por NOME (string).
 * * Complexidade O(N^2). Lenta, mas simples de implementar.
 */
void bubbleSortNome(Componente componentes[], int tamanho, long long *comparacoes) {
    *comparacoes = 0;
    for (int i = 0; i < tamanho - 1; i++) {
        for (int j = 0; j < tamanho - 1 - i; j++) {
            (*comparacoes)++;
            // Compara os nomes dos componentes
            if (strcmp(componentes[j].nome, componentes[j + 1].nome) > 0) {
                trocar(&componentes[j], &componentes[j + 1]);
            }
        }
    }
}

/**
 * @brief Implementa o Insertion Sort para ordenar por TIPO (string).
 * * Complexidade O(N^2). Mais r√°pido que Bubble Sort para vetores quase ordenados.
 */
void insertionSortTipo(Componente componentes[], int tamanho, long long *comparacoes) {
    *comparacoes = 0;
    for (int i = 1; i < tamanho; i++) {
        Componente chave = componentes[i];
        int j = i - 1;
        
        // Compara os tipos e insere a chave na posi√ß√£o correta
        while (j >= 0) {
            (*comparacoes)++;
            if (strcmp(componentes[j].tipo, chave.tipo) > 0) {
                componentes[j + 1] = componentes[j];
                j = j - 1;
            } else {
                break;
            }
        }
        componentes[j + 1] = chave;
    }
}

/**
 * @brief Implementa o Selection Sort para ordenar por PRIORIDADE (int).
 * * Complexidade O(N^2). Faz o menor n√∫mero de trocas, bom para mem√≥ria limitada.
 */
void selectionSortPrioridade(Componente componentes[], int tamanho, long long *comparacoes) {
    *comparacoes = 0;
    for (int i = 0; i < tamanho - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < tamanho; j++) {
            (*comparacoes)++;
            // Compara as prioridades (menor n√∫mero = maior prioridade)
            if (componentes[j].prioridade < componentes[min_idx].prioridade) {
                min_idx = j;
            }
        }
        // Troca o elemento encontrado com o elemento atual
        if (min_idx != i) {
            trocar(&componentes[i], &componentes[min_idx]);
        }
    }
}

// --------------------------------------------------------------------------
//                               BUSCA EFICIENTE
// --------------------------------------------------------------------------

/**
 * @brief Implementa a Busca Bin√°ria por NOME (string). Requer vetor ordenado por nome.
 * * Complexidade O(log N). Muito mais eficiente em grandes conjuntos de dados.
 */
int buscaBinariaPorNome(const Componente componentes[], int tamanho, const char chave[], long long *comparacoes) {
    *comparacoes = 0;
    int inicio = 0;
    int fim = tamanho - 1;

    while (inicio <= fim) {
        int meio = (inicio + fim) / 2;
        (*comparacoes)++;
        int resultadoComparacao = strcmp(componentes[meio].nome, chave);

        if (resultadoComparacao == 0) {
            return meio; // Componente encontrado
        } else if (resultadoComparacao < 0) {
            inicio = meio + 1; // Busca na metade superior
        } else {
            fim = meio - 1; // Busca na metade inferior
        }
    }
    return -1; // Componente n√£o encontrado
}

// --------------------------------------------------------------------------
//                                  EXECU√á√ÉO
// --------------------------------------------------------------------------

/**
 * @brief Fun√ß√£o que processa a ordena√ß√£o e exibe o desempenho.
 */
void processarOrdenacao(int opcao) {
    clock_t start, end;
    double cpu_time_used;
    long long comparacoes = 0;

    // Cria uma c√≥pia tempor√°ria para garantir que a ordena√ß√£o seja feita
    // sobre um estado n√£o ordenado (para medir o desempenho de forma justa).
    // Nota: Aqui estamos usando o vetor principal para simplificar, mas em
    // um jogo real far√≠amos c√≥pias para testar o pior caso.

    start = clock();
    switch (opcao) {
        case 1:
            bubbleSortNome(torre, numComponentes, &comparacoes);
            printf("\n--- üìù Resultado da Ordena√ß√£o: Bubble Sort (por Nome) ---\n");
            break;
        case 2:
            insertionSortTipo(torre, numComponentes, &comparacoes);
            printf("\n--- üìù Resultado da Ordena√ß√£o: Insertion Sort (por Tipo) ---\n");
            break;
        case 3:
            selectionSortPrioridade(torre, numComponentes, &comparacoes);
            printf("\n--- üìù Resultado da Ordena√ß√£o: Selection Sort (por Prioridade) ---\n");
            break;
    }
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

    mostrarComponentes(torre, numComponentes);
    
    // Feedback de Desempenho
    printf("\n--- üìä An√°lise de Desempenho ---\n");
    printf("Compara√ß√µes Realizadas: %lld\n", comparacoes);
    printf("Tempo de Execu√ß√£o (s): %f\n", cpu_time_used);
    printf("-------------------------------\n");
}

/**
 * @brief Fun√ß√£o que executa a busca bin√°ria.
 */
void executarBuscaBinaria() {
    long long comparacoes = 0;
    
    // A busca bin√°ria √© baseada no nome, ent√£o garantimos que a lista esteja ordenada por nome
    processarOrdenacao(1); // Ordena por nome (Bubble Sort)

    printf("\n--- üöÄ Busca Bin√°ria do Componente-Chave ---\n");
    
    clock_t start = clock();
    int posicao = buscaBinariaPorNome(torre, numComponentes, CHAVE_BUSCA, &comparacoes);
    clock_t end = clock();
    double cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

    printf("Componente-Chave Procurado: **%s**\n", CHAVE_BUSCA);
    
    if (posicao != -1) {
        printf("‚úÖ **Componente-Chave ENCONTRADO!** Posi√ß√£o no vetor: %d\n", posicao);
        printf("Montagem da Torre de Resgate Destravada!\n");
    } else {
        printf("‚ùå Componente-Chave n√£o encontrado! Montagem ABORTADA.\n");
    }
    
    // Feedback de Desempenho
    printf("\n--- üìä An√°lise de Desempenho da Busca ---\n");
    printf("Compara√ß√µes Realizadas: %lld\n", comparacoes);
    printf("Tempo de Execu√ß√£o (s): %f\n", cpu_time_used);
    printf("----------------------------------------\n");
}

/**
 * @brief Menu de Interface Amig√°vel
 */
void menuPrincipal() {
    int opcao;

    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë  üöÅ M√ìDULO AVAN√áADO: Montagem da Torre de Resgate üöÅ ‚ïë\n");
    printf("‚ïë         Escolha sua Estrat√©gia de Organiza√ß√£o         ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    inicializarDados();

    do {
        mostrarComponentes(torre, numComponentes); // Exibe o estado atual
        
        printf("\n--- Escolha sua Estrat√©gia (Ordena√ß√£o) ---\n");
        printf("1. üí® **Bubble Sort** (Organizar por **Nome**)\n");
        printf("2. üíæ **Insertion Sort** (Organizar por **Tipo**)\n");
        printf("3. üéØ **Selection Sort** (Organizar por **Prioridade**)\n");
        printf("4. üöÄ **Buscar Componente-Chave** (Busca Bin√°ria)\n");
        printf("0. üö™ Sair do Jogo\n");
        printf("Op√ß√£o: ");
        
        if (scanf("%d", &opcao) != 1) {
            printf("‚ö†Ô∏è Entrada inv√°lida. Tente novamente.\n");
            while (getchar() != '\n'); 
            opcao = -1;
            continue;
        }

        switch (opcao) {
            case 1:
            case 2:
            case 3:
                processarOrdenacao(opcao);
                break;
            case 4:
                executarBuscaBinaria();
                break;
            case 0:
                printf("\nüëã Jogo finalizado. Boa sorte na fuga!\n");
                break;
            default:
                printf("\nOp√ß√£o inv√°lida. Tente novamente.\n");
        }
    } while (opcao != 0);
}

// --------------------------------------------------------------------------
//                                   MAIN
// --------------------------------------------------------------------------

int main() {
    menuPrincipal();
    return 0;
}